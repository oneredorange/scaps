projects {
  scala-library {
    url = "http://central.maven.org/maven2/org/scala-lang/scala-library/2.11.5/scala-library-2.11.5-sources.jar"
    dependencies = [
  	  ${scala-library}
  	]
  }
}

queries {
  "Int => String" = [
    "scala.Int#toString: <memberAccess>[scala.Int, <methodInvocation0>[java.lang.String]]"
  ]
  "max: Int" = [
  	"scala.Int.MaxValue: scala.Int"
  ]
  "max: (Int, Int) => Int" = [
    "scala.math.max: <methodInvocation2>[scala.Int, scala.Int, scala.Int]"
    "scala.runtime.RichInt#max: <memberAccess>[scala.runtime.RichInt, <methodInvocation1>[scala.Int, scala.Int]]"
    "scala.math.Numeric.IntIsIntegral#max: <memberAccess>[scala.math.Numeric.IntIsIntegral, <methodInvocation2>[scala.Int, scala.Int, scala.Int]]"
  ]
  "Ordering[Char]" = [
    "scala.math.Numeric.CharIsIntegral: <refinement3>[java.lang.Object, scala.math.Numeric.CharIsIntegral, scala.math.Ordering.CharOrdering]"
    "scala.math.Ordering.Char: <refinement2>[java.lang.Object, scala.math.Ordering.CharOrdering]"
    "scala.math.Numeric.CharIsIntegral.reverse: scala.math.Ordering[scala.Char]"
    "scala.math.Ordering.Char.reverse: scala.math.Ordering[scala.Char]"
  ]
  "List => java.util.List" = [
    "scala.collection.JavaConversions.seqAsJavaList[A]: <methodInvocation1>[scala.collection.Seq[A], java.util.List[A]]"
    "scala.collection.convert.WrapAsJava.seqAsJavaList[A]: <methodInvocation1>[scala.collection.Seq[A], java.util.List[A]]"
  ]
  "java.util.List => collection.Iterable" = [
    "scala.collection.JavaConversions.asScalaBuffer[A]: <methodInvocation1>[java.util.List[A], scala.collection.mutable.Buffer[A]]"
    "scala.collection.convert.WrapAsScala.asScalaBuffer[A]: <methodInvocation1>[java.util.List[A], scala.collection.mutable.Buffer[A]]"
  ]
  "(Int, Int) => Range" = [
    "scala.collection.immutable.Range.apply: <methodInvocation2>[scala.Int, scala.Int, scala.collection.immutable.Range]"
    "scala.runtime.RichInt#until: <memberAccess>[scala.runtime.RichInt, <methodInvocation1>[scala.Int, scala.collection.immutable.Range]]"
    "scala.collection.immutable.Range.inclusive: <methodInvocation2>[scala.Int, scala.Int, scala.collection.immutable.Range.Inclusive]"
    "scala.runtime.RichInt#to: <memberAccess>[scala.runtime.RichInt, <methodInvocation1>[scala.Int, scala.collection.immutable.Range.Inclusive]]"
  ]
  "exclusive: (Int, Int) => Range" = [
    "scala.collection.immutable.Range.apply: <methodInvocation2>[scala.Int, scala.Int, scala.collection.immutable.Range]"
    "scala.runtime.RichInt#until: <memberAccess>[scala.runtime.RichInt, <methodInvocation1>[scala.Int, scala.collection.immutable.Range.Inclusive]]"
  ]
  "step: (Range, Int) => Range" = [
    "scala.collection.immutable.Range#by: <memberAccess>[scala.collection.immutable.Range, <methodInvocation1>[scala.Int, scala.collection.immutable.Range]]"
  ]
  "(List[Char], String) => String" = [
    "scala.collection.immutable.List#mkString[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[java.lang.String, java.lang.String]]"
  ]
  "(List[A], String) => String" = [
    "scala.collection.immutable.List#mkString[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[java.lang.String, java.lang.String]]"
  ]
  "(List[Char], String, String, String) => String" = [
    "scala.collection.immutable.List#mkString[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation3>[java.lang.String, java.lang.String, java.lang.String, java.lang.String]]"
  ]
  "(List[A], String, String, String) => String" = [
    "scala.collection.immutable.List#mkString[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation3>[java.lang.String, java.lang.String, java.lang.String, java.lang.String]]"
  ]
  "(List[A], Int) => A" = [
  	"scala.collection.immutable.List#apply[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Int, A]]"
  ]
  "List[A] => (A => Boolean) => List[A]" = [
    "scala.collection.immutable.List#filterNot[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.Boolean], scala.collection.immutable.List[A]]]"
    "scala.collection.immutable.List#filter[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.Boolean], scala.collection.immutable.List[A]]]"
    "scala.collection.immutable.List#withFilter[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.Boolean], scala.collection.generic.FilterMonadic[A, scala.collection.immutable.List[A]]]]"
  ]
  "Option[Option[Char]] => Option[Char]" = [
    "scala.Option#flatten[A, B]: <memberAccess>[scala.Option[A], <methodInvocation1>[scala.Predef.<:<[A, scala.Option[B]], scala.Option[B]]]"
  ]
  "Option[Option[A]] => Option[A]" = [
    "scala.Option#flatten[A, B]: <memberAccess>[scala.Option[A], <methodInvocation1>[scala.Predef.<:<[A, scala.Option[B]], scala.Option[B]]]"
  ]
  "List[Option[Char]] => List[Char]" = [
    "scala.collection.immutable.List#flatten[A, B]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.collection.GenTraversableOnce[B]], scala.collection.immutable.List[B]]]"
  ]
  "List[Option[A]] => List[A]" = [
    "scala.collection.immutable.List#flatten[A, B]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.collection.GenTraversableOnce[B]], scala.collection.immutable.List[B]]]"
  ]
  "List[Future[Float]] => Future[List[Float]]" = [
    "scala.concurrent.Future.sequence[A, M <: scala.collection.TraversableOnce]: <methodInvocation1>[M[scala.concurrent.Future[A]], <methodInvocation2>[scala.collection.generic.CanBuildFrom[M[scala.concurrent.Future[A]], A, M[A]], scala.concurrent.ExecutionContext, scala.concurrent.Future[M[A]]]]"
  ]
  "List[Future[A]] => Future[List[A]]" = [
    "scala.concurrent.Future.sequence[A, M <: scala.collection.TraversableOnce]: <methodInvocation1>[M[scala.concurrent.Future[A]], <methodInvocation2>[scala.collection.generic.CanBuildFrom[M[scala.concurrent.Future[A]], A, M[A]], scala.concurrent.ExecutionContext, scala.concurrent.Future[M[A]]]]"
  ]
  "ExecutionContext" = [
    "scala.concurrent.ExecutionContext.Implicits.global: scala.concurrent.ExecutionContextExecutor"
  ]
  "sort: Array[Float] => _" = [
    "scala.util.Sorting.quickSort: <methodInvocation1>[scala.Array[scala.Float], scala.Unit]"
    "scala.util.Sorting.quickSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation1>[scala.math.Ordering[K], scala.Unit]]"
    "scala.util.Sorting.stableSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation2>[scala.reflect.ClassTag[K], scala.math.Ordering[K], scala.Unit]]"
  ]
  "sort: (Array[A], Ordering[A]) => _" = [
    "scala.util.Sorting.quickSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation1>[scala.math.Ordering[K], scala.Unit]]"
    "scala.util.Sorting.stableSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation2>[scala.reflect.ClassTag[K], scala.math.Ordering[K], scala.Unit]]"
  ]
  "sort: Array[A] => _" = [
    "scala.util.Sorting.quickSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation1>[scala.math.Ordering[K], scala.Unit]]"
    "scala.util.Sorting.stableSort[K]: <methodInvocation1>[scala.Array[K], <methodInvocation2>[scala.reflect.ClassTag[K], scala.math.Ordering[K], scala.Unit]]"
  ]
  "List[Char] => (List[Char], List[Char])" = [
    "scala.collection.immutable.List#splitAt[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Int, scala.Tuple2[scala.collection.immutable.List[A], scala.collection.immutable.List[A]]]]"
    "scala.collection.immutable.List#span[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.Boolean], scala.Tuple2[scala.collection.immutable.List[A], scala.collection.immutable.List[A]]]]"
  ]
  "List[A] => (List[A], List[A])" = [
    "scala.collection.immutable.List#splitAt[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Int, scala.Tuple2[scala.collection.immutable.List[A], scala.collection.immutable.List[A]]]]"
    "scala.collection.immutable.List#span[A]: <memberAccess>[scala.collection.immutable.List[A], <methodInvocation1>[scala.Function1[A, scala.Boolean], scala.Tuple2[scala.collection.immutable.List[A], scala.collection.immutable.List[A]]]]"
  ]
  "shuffle: List[Float] => List[Float]" = [
    "scala.util.Random.shuffle[T, CC <: scala.collection.TraversableOnce]: <methodInvocation1>[CC[T], <methodInvocation1>[scala.collection.generic.CanBuildFrom[CC[T], T, CC[T]], CC[T]]]"
    "scala.util.Random#shuffle[T, CC <: scala.collection.TraversableOnce]: <memberAccess>[scala.util.Random, <methodInvocation1>[CC[T], <methodInvocation1>[scala.collection.generic.CanBuildFrom[CC[T], T, CC[T]], CC[T]]]]"
  ]
  "shuffle: List[A] => List[A]" = [
    "scala.util.Random.shuffle[T, CC <: scala.collection.TraversableOnce]: <methodInvocation1>[CC[T], <methodInvocation1>[scala.collection.generic.CanBuildFrom[CC[T], T, CC[T]], CC[T]]]"
    "scala.util.Random#shuffle[T, CC <: scala.collection.TraversableOnce]: <memberAccess>[scala.util.Random, <methodInvocation1>[CC[T], <methodInvocation1>[scala.collection.generic.CanBuildFrom[CC[T], T, CC[T]], CC[T]]]]"
  ]
  "(collection.Seq[A], collection.Seq[B]) => collection.Seq[(A, B)]" = [
    "scala.collection.Seq#zip[A, A1 >: A, B, That]: <memberAccess>[scala.collection.Seq[A], <methodInvocation1>[scala.collection.GenIterable[B], <methodInvocation1>[scala.collection.generic.CanBuildFrom[scala.collection.Seq[A], scala.Tuple2[A1, B], That], That]]]"
    "scala.runtime.Tuple2Zipped.Ops#zipped[T1, T2, El1, Repr1, El2, Repr2]: <memberAccess>[scala.runtime.Tuple2Zipped.Ops[T1, T2], <methodInvocation2>[scala.Function1[T1, scala.collection.TraversableLike[El1, Repr1]], scala.Function1[T2, scala.collection.IterableLike[El2, Repr2]], scala.runtime.Tuple2Zipped[El1, Repr1, El2, Repr2]]]"
  	"scala.runtime.Tuple2Zipped.Ops#invert[T1, T2, El1, CC1 <: scala.collection.TraversableOnce, El2, CC2 <: scala.collection.TraversableOnce, That]: <memberAccess>[scala.runtime.Tuple2Zipped.Ops[T1, T2], <methodInvocation3>[scala.Predef.<:<[T1, CC1[El1]], scala.Predef.<:<[T2, CC2[El2]], scala.collection.generic.CanBuildFrom[CC1[scala.Any], scala.Tuple2[El1, El2], That], That]]"
  ]
  "random: Double" = [
    "scala.util.Random.nextDouble: <methodInvocation0>[scala.Double]"
    "scala.util.Random.nextGaussian: <methodInvocation0>[scala.Double]"
    "scala.math.random: scala.Double"
  ]
  "(List[A], Int) => Option[A]" = [
    "scala.collection.immutable.List#lift[A]: <memberAccess>[scala.collection.immutable.List[A], scala.Function1[scala.Int, scala.Option[A]]]"
  ]
}